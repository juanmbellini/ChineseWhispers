package ar.edu.itba.pdc.chinese_whispers.xmpp_protocol.processors;

import ar.edu.itba.pdc.chinese_whispers.xmpp_protocol.handlers.ErrorManager;
import ar.edu.itba.pdc.chinese_whispers.xmpp_protocol.interfaces.OutputConsumer;
import ar.edu.itba.pdc.chinese_whispers.xmpp_protocol.xml_parser.ParserResponse;
import com.fasterxml.aalto.AsyncXMLStreamReader;

import javax.xml.stream.XMLStreamException;
import java.util.*;

import static ar.edu.itba.pdc.chinese_whispers.xmpp_protocol.xml_parser.ParserResponse.*;

/**
 * This class is in charge of performing the negotiation process with XMPP clients.
 * <p>
 * Created by jbellini on 11/11/16.
 */
public class ServerNegotiationProcessor extends BaseXMLInterpreter {

    /**
     * Contains the parameters that were sent in the initiating stream tag.
     */
    private final Map<String, String> initialParameters;
    /**
     * A string builder to generate tags.
     */
    private final StringBuilder stringBuilder;
    /**
     * The plain authentication text.
     */
    private String builtAuthentication = "";
    /**
     * The state machine that will perform action based on the negotiation state.
     */
    private final NegotiationStateMachine stateMachine;


    /**
     * Constructor.
     *
     * @param outputConsumer An object to which data must be sent when processing the negotiation.
     */
    public ServerNegotiationProcessor(OutputConsumer outputConsumer) {
        super(outputConsumer);
        this.initialParameters = new HashMap<>();
        this.stringBuilder = new StringBuilder();
        this.stateMachine = new NegotiationStateMachine();
    }

    /**
     * Gets the plain authentication text.
     *
     * @return The plain authentication text.
     */
    public String getAuthentication() {
        return builtAuthentication;
    }

    /**
     * Gets the parameters and values contained in the initiating stream tag.
     *
     * @return The parameters and values contained in the initiating stream tag.
     */
    public Map<String, String> getInitialParameters() {
        return initialParameters;
    }


    @Override
    protected ParserResponse process() throws XMLStreamException {
        if (!parser.hasNext()) {
            return ParserResponse.EVERYTHING_NORMAL;
        }
        stringBuilder.setLength(0); // Clears the string builder

        ParserResponse response = ParserResponse.EVERYTHING_NORMAL;
        while (parser.hasNext()) {
            next();
            if (getParserStatus() == AsyncXMLStreamReader.EVENT_INCOMPLETE) {
                break;
            } /*else if (getParserStatus() == AsyncXMLStreamReader.CHARACTERS) {
                String aux = parser.getText();
                if (aux != null
                        && (aux.contains(" ") || aux.contains("\t") || aux.contains("\n") || aux.contains("\r"))) {
                    ignoreText();
                    break;
                }
            } */ else if (getParserStatus() == -1) {
                response = ParserResponse.XML_ERROR;
                break;
            }
            response = this.stateMachine.negotiate();
            // Stop negotiation if an error occurred.
            if (ErrorManager.getInstance().parserResponseErrors().contains(response)) {
                break;
            }
        }
        return response;
    }


    /**
     * This class represents a state machine which can handle all the negotiation with xmpp clients process.
     */
    private class NegotiationStateMachine {

        /**
         * Holds the actual state of this state machine
         */
        private State state;

        /**
         * Constructor.
         * Note: The initial state is {@link PrologueStatus} state.
         */
        private NegotiationStateMachine() {
            this.state = new PrologueStatus();
        }

        /**
         * Makes the state machine process the next action, based on its state.
         *
         * @return The {@link ParserResponse} generated by the processed action.
         */
        private ParserResponse negotiate() {
            return state.action();
        }

        /**
         * Sets the state of this state machine.
         *
         * @param state The new {@link State} for this state machine.
         */
        private void setState(State state) {
            this.state = state;
        }


        /**
         * A {@link NegotiationStateMachine} abstract state. Each state must extends this basic class.
         */
        private abstract class State {

            /**
             * Action that is performed when state machine is on this state.
             *
             * @return The {@link ParserResponse} generated by this action.
             */
            abstract ParserResponse action();
        }


        /**
         * The {@link NegotiationStateMachine} initial state. It just checks xml document version and encoding
         */
        private class PrologueStatus extends State {

            @Override
            protected ParserResponse action() {
                ParserResponse response = ParserResponse.EVERYTHING_NORMAL;
                switch (getParserStatus()) {
                    case AsyncXMLStreamReader.START_DOCUMENT:
                        // We check xml version and encoding in order to log any issue.

                        String streamVersion = parser.getVersion();
                        // If streamVersion is null, we assume 1.0 version.
                        if (streamVersion != null && !streamVersion.equals("1.0")) {
                            System.out.println("Warning: stream version is " + streamVersion); // TODO: use logger
                        }

                        String streamEncoding = parser.getEncoding();
                        // If streamEncoding is null, we assume UTF-8 encoding.
                        if (streamEncoding != null && !streamEncoding.equals("UTF-8")) {
                            System.out.println("Warning: stream encoding is " + streamEncoding); // TODO: use logger
                        }
                        // After checking the document, proceed as if the status is a START_ELEMENT
                    case AsyncXMLStreamReader.START_ELEMENT:
                        setState(new StreamStatus());
                        break;
                    case AsyncXMLStreamReader.EVENT_INCOMPLETE:
                        break;
                    default:
                        response = ParserResponse.XML_ERROR;
                }
                return response;
            }
        }

        /**
         * State in charge of receiving the initial stream sent by an xmpp client.
         * It will check that the "to" parameter is present.
         * It also initiates a stream with the client, sending as a feature the plain mechanism for authenticating.
         */
        private class StreamStatus extends State {


            private static final String END_OF_STREAM_TAG = "xmlns:stream=\'http://etherx.jabber.org/streams\' " +
                    "xmlns=\'jabber:client\' " +
                    "xmlns:xml=\'http://www.w3.org/XML/1998/namespace\'>";
            private static final String FEATURES = "<stream:features> " +
                    "<mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'> " +
                    "<mechanism>PLAIN</mechanism> " +
                    "</mechanisms> " +
                    "</stream:features>";

            /**
             * Attributes added by this state to the response stream.
             */
            private final Set<String> ownAddedAttributes;

            private StreamStatus() {
                this.ownAddedAttributes = new HashSet<>();
                // Aalto excludes namespace definitions
                ownAddedAttributes.add("id");
            }

            @Override
            protected ParserResponse action() {
                ParserResponse response = ParserResponse.EVERYTHING_NORMAL;

                switch (getParserStatus()) {
                    case AsyncXMLStreamReader.START_ELEMENT:
                        if (!parser.getLocalName().equals("stream")) {
                            return ParserResponse.XML_ERROR; // TODO: Bad format xml
                        }

                        stringBuilder.append("<stream:stream");
                        int attrCount = parser.getAttributeCount();
                        if (attrCount > 0) {
                            stringBuilder.append(" ");

                            StringBuilder attributeFullName = new StringBuilder(); // TODO: check if can be bla bla bla
                            for (int i = 0; i < attrCount; i++) {
                                attributeFullName.setLength(0); // Clears the string buffer

                                // Ignore those attributes sent by us
                                if (ownAddedAttributes.contains(parser.getAttributeLocalName(i).toLowerCase())) {
                                    continue;
                                }

                                if (!parser.getAttributePrefix(i).isEmpty()) {
                                    attributeFullName.append(parser.getAttributePrefix(i)).append(":");
                                }
                                attributeFullName.append(parser.getAttributeLocalName(i));
                                switch (attributeFullName.toString()) {
                                    case "to":
                                        stringBuilder.append("from");
                                        break;
                                    case "from":
                                        stringBuilder.append("to");
                                        break;
                                    default:
                                        stringBuilder.append(attributeFullName);
                                }
                                stringBuilder.append("=\'")
                                        .append(parser.getAttributeValue(i))
                                        .append("\'")
                                        .append(i < attrCount - 1 ? " " : "");
                                if (!initialParameters.containsKey(attributeFullName.toString())) {
                                    initialParameters.put(attributeFullName.toString(), parser.getAttributeValue(i));
                                }
                            }

                            if (!initialParameters.containsKey("to")) {
                                return ParserResponse.HOST_UNKNOWN; // Do not continue if missing "to" param
                            }
                        }
                        stringBuilder.append(" id=\'")
                                .append(IdGenerator.generateId())
                                .append("\' ");                     // The id param.
                        stringBuilder.append(END_OF_STREAM_TAG);    // The rest of the stream tag
                        stringBuilder.append(FEATURES);             // Features

                        outputConsumer.consumeMessage(stringBuilder.toString().getBytes());
                        setState(new AuthState());
                        break;
                    case AsyncXMLStreamReader.EVENT_INCOMPLETE:
                        break;
                    default:
                        response = ParserResponse.XML_ERROR;
                }
                return response;
            }
        }

        private class AuthState extends State {


            /**
             * The {@link StringBuilder} that will build the authentication text string.
             */
            private final StringBuilder authenticationBuilder = new StringBuilder();

            private boolean validMechanism = false;


            @Override
            ParserResponse action() {
                ParserResponse response = ParserResponse.EVERYTHING_NORMAL;

                switch (getParserStatus()) {
                    case AsyncXMLStreamReader.START_ELEMENT:
                        if (!parser.getLocalName().equals("auth")) {
                            return response;
                        }
                        int attrCount = parser.getAttributeCount();
                        if (attrCount > 0) {
                            StringBuilder attributeFullName = new StringBuilder();
                            for (int i = 0; i < attrCount; i++) {
                                attributeFullName.setLength(0); // Clears the string buffer

                                if (!parser.getAttributePrefix(i).isEmpty()) {
                                    attributeFullName.append(parser.getAttributePrefix(i)).append(":");
                                }
                                attributeFullName.append(parser.getAttributeLocalName(i));

                                if (attributeFullName.toString().equals("mechanism")) {
                                    String mechanismValue = parser.getAttributeValue(i);
                                    if (mechanismValue.toUpperCase().equals("PLAIN")) {
                                        validMechanism = true;
                                    }
                                }
                            }
                        }
                        if (!validMechanism) {
                            return ParserResponse.INVALID_AUTH_MECHANISM;
                        }
                        authenticationBuilder.setLength(0);
                        break;
                    case AsyncXMLStreamReader.CHARACTERS:
                        if (validMechanism) {
                            authenticationBuilder.append(parser.getText());
                        }
                        break;
                    case AsyncXMLStreamReader.END_ELEMENT:
                        builtAuthentication = authenticationBuilder.toString();
                        // Checks that something was sent in the auth body
                        if (builtAuthentication.isEmpty()) {
                            return ParserResponse.MALFORMED_REQUEST;
                        }
                        String decodedAuth;
                        // Checks that the body has a correct base64 scheme
                        try {
                            // The authorization content might be invalid (i.e. not be a valid base64 scheme)
                            decodedAuth = new String(Base64.getDecoder().decode(builtAuthentication));
                        } catch (IllegalArgumentException e) {
                            return ParserResponse.MALFORMED_REQUEST;
                        }
                        // Checks that the decoded string can be separated in 2 or 3 elements separated by a zero.
                        int authParametersAmount = decodedAuth.split("\0").length;
                        if (authParametersAmount != 2 && authParametersAmount != 3) {
                            return ParserResponse.MALFORMED_REQUEST;
                        }

                        setState(new FinalState());
                        response = ParserResponse.NEGOTIATION_END;
                        break;
                    case AsyncXMLStreamReader.EVENT_INCOMPLETE:
                        break;
                    default:
                        response = ParserResponse.XML_ERROR;
                }
                return response;
            }
        }

        private class FinalState extends State {


            @Override
            ParserResponse action() {
                return ParserResponse.NEGOTIATION_END;
            }
        }

    }

    /**
     * This class implements a method to get different ids each time its called.
     */
    private static class IdGenerator {


        /**
         * This set contains all ids already used
         */
        private final static Set<String> usedIds = new HashSet<>();

        /**
         * Random to get random values
         */
        private final static Random random = new Random();

        /**
         * To get different ids each time, when generating a random value,
         * it is checked if the {@code usedIds} set contains that value.
         * If the set contains the generated value, another value is generated.
         * It might happen (but it is not probable) to enter an infinite loop,
         * so the process is repeated, at most, the amount of times this constant states.
         */
        private final static int MAX_RANDOM_TRIES = 100;
        /**
         * In case the count reached the {@link IdGenerator#MAX_RANDOM_TRIES} value,
         * a fallback strategy is done.
         */
        private static int fallbackIds = 0;


        /**
         * Generates a random and unique id.
         *
         * @return A Stream Id (RFC 6120, section 4.7.3) for the response stream.
         */
        private static String generateId() {

            String result;
            int count = 0;
            do {
                result = String.valueOf(random.nextLong());
                count++;
            }
            while (usedIds.contains(result) && count < MAX_RANDOM_TRIES);
            if (count >= MAX_RANDOM_TRIES) {
                result = "NotRandom" + String.valueOf(fallbackIds++);
            }
            usedIds.add(result);
            return result;
        }
    }
}
