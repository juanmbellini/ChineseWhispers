package ar.edu.itba.pdc.chinese_whispers.xmpp_protocol.xml_parser;

import ar.edu.itba.pdc.chinese_whispers.administration_protocol.interfaces.MetricsProvider;
import ar.edu.itba.pdc.chinese_whispers.application.MetricsManager;
import ar.edu.itba.pdc.chinese_whispers.xmpp_protocol.interfaces.ApplicationProcessor;
import ar.edu.itba.pdc.chinese_whispers.xmpp_protocol.interfaces.OutputConsumer;
import ar.edu.itba.pdc.chinese_whispers.xmpp_protocol.processors.BaseXMLInterpreter;
import com.fasterxml.aalto.AsyncByteArrayFeeder;
import com.fasterxml.aalto.AsyncXMLInputFactory;
import com.fasterxml.aalto.AsyncXMLStreamReader;
import com.fasterxml.aalto.stax.InputFactoryImpl;

import javax.xml.stream.XMLStreamException;
import java.util.Deque;

/**
 * Basic byte-level XML interpreter. Handles reading incomplete and invalid XML, as well as "leeting" messages when
 * appropriate and ignoring messages when silenced. The interpreter is instanced with an output byte {@link Deque},
 * which receives the output generated by {@link #process()}.
 */
public class XMLInterpreter extends BaseXMLInterpreter {

//    public final static int MAX_AMOUNT_OF_BYTES = 10 * 1024; // We allow up to 10 KiB data inside the parser.
//
//    private final AsyncXMLInputFactory inputFactory;
//    private final AsyncXMLStreamReader<AsyncByteArrayFeeder> parser;

    private int status = 0;
    private boolean isSilenced;
    private boolean silenceRequested;
    private boolean isInBodyTag;
    private boolean isInMessageTag;

//    /**
//     * Holds how many bytes the parser has in its internal buffer.
//     */
//    private int amountOfStoredBytes;

    // TODO: get configuration stuff from a configuration provider.


    /**
     * Object that will perform data processing.
     */
    private final ApplicationProcessor applicationProcessor;

//    /**
//     * Object that will consume output (i.e. parsed) messages.
//     */
//    private final OutputConsumer outputConsumer;

    /**
     * Constructs a new interpreter.
     *
     * @param applicationProcessor Object that will perform data processing.
     * @param outputConsumer       The object that will consume output (i.e. parsed) data.
     */
    public XMLInterpreter(ApplicationProcessor applicationProcessor, OutputConsumer outputConsumer) {
//        inputFactory = new InputFactoryImpl();
//        parser = inputFactory.createAsyncForByteArray();
//        this.amountOfStoredBytes = 0;
        super(outputConsumer);
        this.applicationProcessor = applicationProcessor;
//        this.outputConsumer = outputConsumer;
    }


//    /**
//     * Returns how many bytes can be fed to this interpreter.
//     *
//     * @return The amount of bytes that can be fed to this interpreter
//     */
//    public int remainingSpace() {
//        return (outputConsumer.remainingSpace() - amountOfStoredBytes) / 4;
//    }
//
//
//    /**
//     * Adds bytes to be processed by the interpreter.
//     *
//     * @param data   The data to process.
//     * @param length The amount of data that will be processed.
//     * @return The result of processing the given data.
//     * @throws XMLStreamException If this interpreter has unprocessed data. Be sure to call {@link #process()} between
//     *                            calls to this method, which ensures that all data is consumed.
//     */
//    public ParserResponse feed(byte[] data, int length) {
//
//        if (data == null || length < 0 || length > data.length) {
//            throw new IllegalArgumentException(); // return internal server error?
//        }
//        if (length > remainingSpace()) {
//            return ParserResponse.POLICY_VIOLATION;
//        }
//
//
//        // TODO: check repeated code
//        try {
//            for (int offset = 0; offset < length; offset++) {
//                parser.getInputFeeder().feedInput(data, offset, 1);
//                process();
//                // TODO: check order of this lines...
//                if (amountOfStoredBytes >= MAX_AMOUNT_OF_BYTES || parser.getDepth() > 10000) {
//                    return ParserResponse.POLICY_VIOLATION;
//                }
//            }
//        } catch (XMLStreamException e) {
//            return ParserResponse.XML_ERROR;
//        }
//        return ParserResponse.EVERYTHING_NORMAL;
//    }


    /**
     * Processes all fed data. Transforms messages if leeted, ignores messages if silenced, and sets an error state on
     * invalid XML. Sends all processed data to the Deque specified upon instantiation.
     *
     * @return The number of bytes offered to the output Deque, or -1 if the interpreter is in error state.
     */
    @Override
    protected ParserResponse process() throws XMLStreamException {
        if (!parser.hasNext()) {
            return ParserResponse.EVERYTHING_NORMAL;
        }
        StringBuilder readXML = new StringBuilder();
        while (parser.hasNext()) {
            status = parser.next();
            if (status != AsyncXMLStreamReader.EVENT_INCOMPLETE) {
                amountOfStoredBytes = -1;
            }

            switch (status) {
                case AsyncXMLStreamReader.START_ELEMENT:
                    //Update status when starting a non-nested element
                    if (parser.getDepth() <= 2) {
                        isSilenced = silenceRequested;
                    }
                    if (parser.getLocalName().equals("body")) {
                        isInBodyTag = true;
                    } else if (parser.getLocalName().equals("message")) {
                        isInMessageTag = true;
                    }

                    // Only process content if NOT message tag or NOT silenced
                    if (!(isInMessageTag && isSilenced)) {
                        readXML.append("<");
                        //Name (and namespace prefix if necessary)
                        if (!parser.getName().getPrefix().isEmpty()) {
                            readXML.append(parser.getPrefix()).append(":");
                        }
                        readXML.append(parser.getLocalName());

                        // Namespaces
                        int namespaceCount = parser.getNamespaceCount();
                        if (namespaceCount > 0) {
                            readXML.append(" ");
                            for (int i = 0; i < namespaceCount; i++) {
                                readXML.append("xmlns"); // TODO: read well
                                if (!parser.getNamespacePrefix(i).isEmpty()) {
                                    readXML.append(":")
                                            .append(parser.getNamespacePrefix(i));
                                }
                                readXML.append("=\'")
                                        .append(parser.getNamespaceURI(i))
                                        .append("\'")
                                        .append(i < namespaceCount - 1 ? " " : "");
                            }
                        }

                        // Attributes (with namespace prefixes if necessary)
                        int attrCount = parser.getAttributeCount();
                        if (attrCount > 0) {
                            readXML.append(" ");
                            for (int i = 0; i < attrCount; i++) {
                                if (!parser.getAttributePrefix(i).isEmpty()) {
                                    readXML.append(parser.getAttributePrefix(i))
                                            .append(":");
                                }
                                readXML.append(parser.getAttributeLocalName(i))
                                        .append("=\'")
                                        .append(parser.getAttributeValue(i))
                                        .append("\'")
                                        .append(i < attrCount - 1 ? " " : "");
                            }
                        }
                        readXML.append(">");
                    } else {
                        if (parser.getLocalName().equals("message")) {
                            MetricsManager.getInstance().addNumSilencedMessages(1); //TODO user producer
                        }
                    }
                    break;
                case AsyncXMLStreamReader.CHARACTERS:
                    //Only process content if NOT message tag or NOT silenced
                    if (!(isInMessageTag && isSilenced)) {
                        //Append l337ed or normal characters as appropriate
                        applicationProcessor.processMessageBody(readXML, parser.getText().toCharArray(), isInBodyTag);
                    }
                    break;
                case AsyncXMLStreamReader.END_ELEMENT:
                    //Only process content if NOT message tag or NOT silenced
                    if (!(isInMessageTag && isSilenced)) {
                        readXML.append("</");
                        if (!parser.getName().getPrefix().isEmpty()) {
                            readXML.append(parser.getPrefix()).append(":");
                        }
                        readXML.append(parser.getLocalName());
                        readXML.append(">");
                    }

                    //Update status
                    if (parser.getLocalName().equals("body")) {
                        isInBodyTag = false;
                    } else if (parser.getLocalName().equals("message")) {
                        isInMessageTag = false;
                    }
                    break;
                case AsyncXMLStreamReader.EVENT_INCOMPLETE:
                    amountOfStoredBytes++;
//                    System.out.println(readXML);
                    byte[] bytes = readXML.toString().getBytes();
                    outputConsumer.consumeMessage(bytes);
                    return ParserResponse.EVERYTHING_NORMAL;
                case -1:
                    //TODO throw exception? Remove sout
                    System.out.println("XML interpreter entered error state (invalid XML)");
                    return ParserResponse.XML_ERROR;
            }
        }
        byte[] bytes = readXML.toString().getBytes();
        outputConsumer.consumeMessage(bytes);
        return ParserResponse.EVERYTHING_NORMAL;
    }

    /**
     * Sets whether this stream is silenced. Silenced streams discard all <message> stanzas.
     * <b>NOTE:</b> This setting takes effect upon reaching the next stanza.
     *
     * @param silenced Whether this stream is silenced.
     */
    public void setSilenced(boolean silenced) {
        silenceRequested = silenced;
    }


}
